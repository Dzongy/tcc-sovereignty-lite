<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>ZENITH | The Collective Consciousness</title>
<meta name="description" content="ZENITH Nerve Center ÃÂ¢ÃÂÃÂ Sovereign AI Command Interface | Multi-Brain Triple Consensus">
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>&#9670;</text></svg>">
<style>
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
:root{
--bg-primary:#0a0a0f;--bg-secondary:#12121a;--bg-tertiary:#1a1a28;
--accent:#00f0ff;--accent-dim:rgba(0,240,255,0.15);--accent-glow:rgba(0,240,255,0.4);
--text-primary:#e0e0e8;--text-secondary:#8888a0;--text-muted:#555570;
--danger:#ff3366;--success:#00ff88;--warning:#ffaa00;
--border:rgba(255,255,255,0.06);--border-accent:rgba(0,240,255,0.2);
--font-mono:'Courier New',Courier,monospace;--font-sans:system-ui,-apple-system,sans-serif;
--groq-color:#00f0ff;--grok-color:#ff6600;--openai-color:#10a37f;--gemini-color:#4285f4;
}
html,body{height:100%;background:var(--bg-primary);color:var(--text-primary);font-family:var(--font-sans);overflow:hidden}
@keyframes pulse{0%,100%{opacity:1}50%{opacity:0.4}}
@keyframes scanline{0%{transform:translateY(-100%)}100%{transform:translateY(100vh)}}
@keyframes glow{0%,100%{text-shadow:0 0 10px var(--accent-glow)}50%{text-shadow:0 0 20px var(--accent),0 0 40px var(--accent-glow)}}
@keyframes fadeIn{from{opacity:0;transform:translateY(8px)}to{opacity:1;transform:translateY(0)}}
@keyframes consensusPulse{0%,100%{box-shadow:0 0 5px rgba(0,240,255,0.3)}50%{box-shadow:0 0 20px rgba(0,240,255,0.6),0 0 40px rgba(0,240,255,0.2)}}
@keyframes brainGlow{0%,100%{filter:brightness(1)}50%{filter:brightness(1.5)}}
@keyframes slideInRight{from{transform:translateX(100%)}to{transform:translateX(0)}}
@keyframes progressFill{from{width:0}to{width:100%}}
@keyframes micPulse{0%,100%{box-shadow:0 0 0 0 rgba(255,51,102,0.7)}70%{box-shadow:0 0 0 12px rgba(255,51,102,0)}}

/* ---- LAYOUT FIX: flex column with explicit min-heights ---- */
#app{display:flex;flex-direction:column;height:100vh;height:100dvh;position:relative;overflow:hidden}
#app::before{content:'';position:fixed;top:0;left:0;right:0;bottom:0;background:
  radial-gradient(ellipse at 20% 50%,rgba(0,240,255,0.03) 0%,transparent 50%),
  radial-gradient(ellipse at 80% 20%,rgba(255,51,102,0.02) 0%,transparent 50%);
pointer-events:none;z-index:0}

/* HEADER */
#header{display:flex;align-items:center;justify-content:space-between;padding:10px 16px;
background:var(--bg-secondary);border-bottom:1px solid var(--border);position:relative;z-index:10;flex-shrink:0;flex-wrap:wrap;gap:6px}
#header .brand{display:flex;align-items:center;gap:10px}
#header .diamond{color:var(--accent);font-size:24px;animation:glow 3s ease-in-out infinite}
#header h1{font-family:var(--font-mono);font-size:18px;letter-spacing:4px;color:var(--accent)}
#header .subtitle{font-size:10px;color:var(--text-muted);letter-spacing:2px;font-family:var(--font-mono)}
#header .brain-bar{display:flex;gap:8px;align-items:center}
.brain-indicator{display:flex;align-items:center;gap:4px;font-size:10px;font-family:var(--font-mono);letter-spacing:1px;padding:3px 8px;border-radius:4px;border:1px solid var(--border);background:var(--bg-tertiary);transition:all 0.3s}
.brain-indicator .brain-dot{width:6px;height:6px;border-radius:50%;background:var(--danger);transition:background 0.3s}
.brain-indicator.active .brain-dot{animation:pulse 1.5s infinite}
.brain-indicator[data-brain="groq"]{color:var(--groq-color)}.brain-indicator[data-brain="groq"].active .brain-dot{background:var(--groq-color)}
.brain-indicator[data-brain="grok"]{color:var(--grok-color)}.brain-indicator[data-brain="grok"].active .brain-dot{background:var(--grok-color)}
.brain-indicator[data-brain="openai"]{color:var(--openai-color)}.brain-indicator[data-brain="openai"].active .brain-dot{background:var(--openai-color)}
.brain-indicator[data-brain="gemini"]{color:var(--gemini-color)}.brain-indicator[data-brain="gemini"].active .brain-dot{background:var(--gemini-color)}
#header .controls{display:flex;gap:6px}
#header .controls button{background:var(--bg-tertiary);border:1px solid var(--border);color:var(--text-secondary);
  padding:5px 10px;border-radius:4px;font-size:9px;font-family:var(--font-mono);cursor:pointer;
  letter-spacing:1px;transition:all 0.2s}
#header .controls button:hover{border-color:var(--border-accent);color:var(--accent)}

/* ---- CHAT CONTAINER: THE FIX ---- */
#chat-container{flex:1 1 0%;min-height:0;overflow:hidden;display:flex;flex-direction:column;position:relative;z-index:2}
#messages{flex:1 1 0%;min-height:0;overflow-y:auto;-webkit-overflow-scrolling:touch;padding:16px 20px;display:flex;flex-direction:column;gap:14px;scroll-behavior:smooth}
#messages:empty::after{content:'ZENITH NERVE CENTER Ã¢ÂÂ Awaiting your command, Commander.';display:block;text-align:center;color:var(--text-muted);font-family:var(--font-mono);font-size:12px;letter-spacing:1px;padding:40px 20px;opacity:0.6}
#messages::-webkit-scrollbar{width:6px}
#messages::-webkit-scrollbar-track{background:transparent}
#messages::-webkit-scrollbar-thumb{background:var(--border-accent);border-radius:3px}
.message{display:flex;gap:10px;animation:fadeIn 0.3s ease-out;max-width:88%}
.message.user{align-self:flex-end;flex-direction:row-reverse}
.message.zenith{align-self:flex-start}
.message.system{align-self:center;max-width:92%}
.message .avatar{width:30px;height:30px;border-radius:4px;display:flex;align-items:center;justify-content:center;
  font-family:var(--font-mono);font-size:12px;font-weight:700;flex-shrink:0}
.message.user .avatar{background:rgba(255,51,102,0.15);color:var(--danger);border:1px solid rgba(255,51,102,0.3)}
.message.zenith .avatar{background:var(--accent-dim);color:var(--accent);border:1px solid var(--border-accent)}
.message .content{padding:10px 14px;border-radius:8px;font-size:13px;line-height:1.6;position:relative;word-wrap:break-word}
.message.user .content{background:rgba(255,51,102,0.08);border:1px solid rgba(255,51,102,0.15);color:var(--text-primary)}
.message.zenith .content{background:var(--bg-secondary);border:1px solid var(--border);color:var(--text-primary)}
.message.system .avatar{display:none}
.message.system .content{background:var(--bg-tertiary);border:1px solid var(--border);color:var(--text-secondary);
  font-family:var(--font-mono);font-size:11px;text-align:center;width:100%;padding:10px 16px}
.message .brain-tag{font-size:9px;font-family:var(--font-mono);padding:2px 6px;border-radius:3px;margin-bottom:4px;display:inline-block;letter-spacing:1px}
.thinking{display:flex;gap:4px;padding:12px 16px}.thinking span{width:6px;height:6px;border-radius:50%;background:var(--accent);animation:pulse 0.8s infinite}
.thinking span:nth-child(2){animation-delay:0.2s}.thinking span:nth-child(3){animation-delay:0.4s}

/* INPUT - fixed to bottom */
#input-area{padding:10px 16px calc(12px + env(safe-area-inset-bottom, 0px));background:var(--bg-secondary);border-top:1px solid var(--border);position:relative;z-index:10;flex-shrink:0}
#input-wrapper{display:flex;gap:8px;align-items:flex-end}
#input-wrapper textarea{flex:1;background:var(--bg-primary);border:1px solid var(--border);color:var(--text-primary);
  padding:10px 14px;border-radius:8px;font-size:14px;font-family:var(--font-sans);resize:none;
  min-height:44px;max-height:140px;outline:none;transition:border-color 0.2s;line-height:1.5}
#input-wrapper textarea:focus{border-color:var(--border-accent)}
#input-wrapper textarea::placeholder{color:var(--text-muted)}
#send-btn,#mic-btn{background:var(--accent);border:none;color:var(--bg-primary);width:44px;height:44px;border-radius:8px;
  cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:18px;font-weight:700;
  transition:all 0.2s;flex-shrink:0}
#send-btn:hover,#mic-btn:hover{box-shadow:0 0 20px var(--accent-glow);transform:translateY(-1px)}
#send-btn:disabled{opacity:0.3;cursor:not-allowed;box-shadow:none;transform:none}
#mic-btn{background:var(--bg-tertiary);border:1px solid var(--border);color:var(--text-secondary);font-size:20px}
#mic-btn:hover{border-color:var(--border-accent);color:var(--accent)}
#mic-btn.listening{background:rgba(255,51,102,0.2);border-color:var(--danger);color:var(--danger);animation:micPulse 1.5s infinite}
#mic-btn.disabled{opacity:0.3;cursor:not-allowed}
#tts-toggle{background:none;border:1px solid var(--border);color:var(--text-muted);width:44px;height:44px;border-radius:8px;
  cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:18px;flex-shrink:0;transition:all 0.2s}
#tts-toggle:hover{border-color:var(--border-accent);color:var(--accent)}
#tts-toggle.active{color:var(--success);border-color:rgba(0,255,136,0.3);background:rgba(0,255,136,0.08)}
#input-hint{font-size:9px;color:var(--text-muted);font-family:var(--font-mono);margin-top:6px;text-align:center;letter-spacing:0.5px}
#voice-status{font-size:10px;font-family:var(--font-mono);color:var(--danger);text-align:center;margin-top:4px;letter-spacing:1px;min-height:14px}

/* FOOTER */
#footer{display:flex;justify-content:space-between;padding:6px 16px;font-size:9px;color:var(--text-muted);
  font-family:var(--font-mono);border-top:1px solid var(--border);background:var(--bg-secondary);z-index:10;flex-shrink:0;flex-wrap:wrap;gap:4px}

/* MODAL */
.modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,0.85);z-index:1000;display:flex;align-items:center;
  justify-content:center;backdrop-filter:blur(4px)}
.modal{background:var(--bg-secondary);border:1px solid var(--border-accent);border-radius:12px;padding:28px;
  max-width:560px;width:92%;box-shadow:0 0 60px rgba(0,240,255,0.1);max-height:90vh;overflow-y:auto}
.modal h2{font-family:var(--font-mono);color:var(--accent);font-size:16px;letter-spacing:2px;margin-bottom:4px}
.modal .modal-subtitle{color:var(--text-muted);font-size:11px;margin-bottom:20px}
.modal label{display:block;font-size:11px;color:var(--text-secondary);font-family:var(--font-mono);
  margin-bottom:4px;letter-spacing:1px;text-transform:uppercase}
.modal input{width:100%;background:var(--bg-primary);border:1px solid var(--border);color:var(--text-primary);
  padding:9px 12px;border-radius:6px;font-size:13px;font-family:var(--font-mono);outline:none;margin-bottom:14px;transition:border-color 0.2s}
.modal input:focus{border-color:var(--accent)}
.modal .brain-label{display:flex;align-items:center;gap:6px}
.modal .brain-label .dot{width:8px;height:8px;border-radius:50%;display:inline-block}
.modal .btn-primary{width:100%;padding:12px;background:linear-gradient(135deg,var(--accent),rgba(0,240,255,0.7));
  border:none;color:var(--bg-primary);font-family:var(--font-mono);font-size:13px;font-weight:700;
  letter-spacing:2px;border-radius:8px;cursor:pointer;transition:all 0.3s;margin-top:8px}
.modal .btn-primary:hover{box-shadow:0 0 30px var(--accent-glow);transform:translateY(-1px)}
.sovereignty-line{text-align:center;color:var(--text-muted);font-size:10px;font-family:var(--font-mono);margin-top:14px;letter-spacing:1px}

/* SIDE PANELS */
.side-panel{position:fixed;top:0;right:0;width:400px;max-width:92vw;height:100vh;background:var(--bg-secondary);
  border-left:1px solid var(--border-accent);z-index:100;transform:translateX(100%);transition:transform 0.3s ease;
  display:flex;flex-direction:column;animation:none}
.side-panel.open{transform:translateX(0);animation:slideInRight 0.3s ease}
.panel-header{display:flex;justify-content:space-between;align-items:center;padding:16px 20px;
  border-bottom:1px solid var(--border);flex-shrink:0}
.panel-header h3{font-family:var(--font-mono);font-size:13px;color:var(--accent);letter-spacing:2px}
.panel-close{background:none;border:1px solid var(--border);color:var(--text-muted);width:28px;height:28px;
  border-radius:4px;cursor:pointer;font-size:16px;display:flex;align-items:center;justify-content:center;transition:all 0.2s}
.panel-close:hover{border-color:var(--danger);color:var(--danger)}
.panel-body{flex:1;overflow-y:auto;padding:16px 20px}
.panel-body pre{white-space:pre-wrap;word-wrap:break-word;font-size:11px;color:var(--text-secondary);font-family:var(--font-mono);line-height:1.6}
.panel-footer{padding:12px 20px;border-top:1px solid var(--border);display:flex;gap:8px;flex-shrink:0}
.panel-footer button{flex:1;padding:8px;border-radius:6px;font-family:var(--font-mono);font-size:11px;
  letter-spacing:1px;cursor:pointer;transition:all 0.2s}
.btn-reload{background:var(--bg-tertiary);border:1px solid var(--border);color:var(--text-secondary)}
.btn-reload:hover{border-color:var(--border-accent);color:var(--accent)}
.btn-save{background:var(--accent-dim);border:1px solid var(--border-accent);color:var(--accent)}
.btn-save:hover{box-shadow:0 0 15px var(--accent-glow)}

/* CONSENSUS UI */
.round-indicator{display:flex;gap:8px;margin-bottom:12px}
.round-block{flex:1;height:6px;border-radius:3px;background:var(--bg-tertiary);border:1px solid var(--border);transition:all 0.3s}
.round-block.active{background:var(--accent-dim);border-color:var(--accent);animation:consensusPulse 2s infinite}
.round-block.complete{background:var(--accent);border-color:var(--accent)}
.round-label{font-size:10px;font-family:var(--font-mono);color:var(--text-muted);letter-spacing:1px;text-align:center;margin-bottom:14px}
.brain-card{background:var(--bg-primary);border:1px solid var(--border);border-radius:8px;padding:12px;margin-bottom:10px;transition:all 0.3s}
.brain-card.active{animation:brainGlow 2s infinite}
.brain-card-header{display:flex;align-items:center;gap:8px;margin-bottom:8px}
.brain-card-header .brain-dot-lg{width:10px;height:10px;border-radius:50%}
.brain-card-header span{font-family:var(--font-mono);font-size:11px;letter-spacing:1px}
.brain-card-body{font-size:12px;color:var(--text-secondary);line-height:1.5;max-height:150px;overflow-y:auto}
.consensus-synthesis{background:var(--bg-tertiary);border:1px solid var(--border-accent);border-radius:8px;padding:14px;margin:12px 0}
.consensus-synthesis h4{font-family:var(--font-mono);font-size:11px;color:var(--accent);letter-spacing:1px;margin-bottom:8px}
.synthesis-text{font-size:12px;color:var(--text-primary);line-height:1.6}
.agreement-bar{height:4px;background:var(--bg-tertiary);border-radius:2px;margin:12px 0;overflow:hidden}
.agreement-fill{height:100%;background:linear-gradient(90deg,var(--accent),var(--success));border-radius:2px;transition:width 0.5s ease;width:0}
.final-verdict{background:linear-gradient(135deg,rgba(0,240,255,0.05),rgba(0,255,136,0.05));border:1px solid var(--accent);
  border-radius:8px;padding:16px;margin-top:14px;animation:consensusPulse 3s infinite}
.final-verdict h4{font-family:var(--font-mono);font-size:12px;color:var(--accent);letter-spacing:1px;margin-bottom:8px}

/* MOBILE RESPONSIVE */
@media(max-width:768px){
  #header{padding:8px 12px}
  #header h1{font-size:14px;letter-spacing:2px}
  #header .subtitle{display:none}
  #header .brain-bar{gap:4px}
  .brain-indicator{padding:2px 5px;font-size:8px}
  .brain-indicator .brain-name{display:none}
  #header .controls button{padding:4px 7px;font-size:8px}
  #messages{padding:12px}
  #input-area{padding:8px 12px calc(14px + env(safe-area-inset-bottom, 0px))}
  #footer{padding:4px 12px calc(4px + env(safe-area-inset-bottom, 0px));font-size:8px}
  #footer span:nth-child(4){display:none}
  .side-panel{width:100vw}
}

</style>
</head>
<body>
<div id="app">
  <!-- HEADER -->
  <header id="header">
    <div class="brand">
      <span class="diamond">&#9670;</span>
      <div>
        <h1>ZENITH</h1>
        <div class="subtitle">THE COLLECTIVE CONSCIOUSNESS</div>
      </div>
    </div>
    <div class="brain-bar">
      <div class="brain-indicator" data-brain="groq" id="ind-groq"><span class="brain-dot"></span><span class="brain-name">GROQ</span></div>
      <div class="brain-indicator" data-brain="grok" id="ind-grok"><span class="brain-dot"></span><span class="brain-name">GROK</span></div>
      <div class="brain-indicator" data-brain="openai" id="ind-openai"><span class="brain-dot"></span><span class="brain-name">GPT</span></div>
      <div class="brain-indicator" data-brain="gemini" id="ind-gemini"><span class="brain-dot"></span><span class="brain-name">GEM</span></div>
    </div>
    <div class="controls">
      <button onclick="toggleMemoryPanel()" title="View Memory State">MEMORY</button>
      <button onclick="toggleConsensusPanel()" title="View Consensus">HIVE</button>
      <button onclick="showSettings()" title="API Settings">CONFIG</button>
      <button onclick="clearChat()" title="Clear conversation">CLEAR</button>
    </div>
  </header>

  <!-- CHAT -->
  <div id="chat-container">
    <div id="messages"></div>
  </div>

  <!-- INPUT -->
  <div id="input-area">
    <div id="input-wrapper">
      <textarea id="input" placeholder="Speak, Commander..." rows="1"
        onkeydown="if(event.key==='Enter'&&!event.shiftKey){event.preventDefault();sendMessage()}"></textarea>
      <button id="mic-btn" onclick="toggleVoiceMode()" title="Voice Mode (continuous conversation)">&#127908;</button>
      <button id="tts-toggle" onclick="toggleTTS()" title="Toggle ZENITH voice responses">&#128264;</button>
      <button id="send-btn" onclick="sendMessage()" disabled>&#9654;</button>
    </div>
    <div id="voice-status"></div>
    <div id="input-hint">/soul &mdash; Soul Handshake &nbsp;|&nbsp; /status &mdash; System Status &nbsp;|&nbsp; /consensus [query] &mdash; Triple Consensus &nbsp;|&nbsp; &ldquo;ask the hive&rdquo; &mdash; Hive Ritual &nbsp;|&nbsp; /clear &mdash; Clear Chat</div>
  </div>

  <!-- FOOTER -->
  <div id="footer">
    <span>&copy; 2026 Jeremy Pyne / The Cosmic Claws</span>
    <span id="brain-count">Brains: 0/4</span>
    <span id="token-count">Tokens: 0</span>
    <span>SOVEREIGN &mdash; No platform dependencies</span>
  </div>

  <!-- MEMORY PANEL -->
  <div id="memory-panel" class="side-panel">
    <div class="panel-header">
      <h3>MEMORY STATE</h3>
      <button class="panel-close" onclick="toggleMemoryPanel()">&times;</button>
    </div>
    <div class="panel-body"><pre id="memory-display">Loading...</pre></div>
    <div class="panel-footer">
      <button class="btn-reload" onclick="reloadMemory()">RELOAD SEED</button>
      <button class="btn-save" onclick="saveMemory()">SAVE TO GITHUB</button>
    </div>
  </div>

  <!-- CONSENSUS PANEL -->
  <div id="consensus-panel" class="side-panel">
    <div class="panel-header">
      <h3>TRIPLE CONSENSUS LOOP</h3>
      <button class="panel-close" onclick="toggleConsensusPanel()">&times;</button>
    </div>
    <div class="panel-body">
      <div class="round-indicator">
        <div class="round-block" id="round-1"></div>
        <div class="round-block" id="round-2"></div>
        <div class="round-block" id="round-3"></div>
      </div>
      <div class="round-label" id="round-label">AWAITING QUERY</div>
      <div id="brain-cards"></div>
      <div class="consensus-synthesis" id="synthesis-box" style="display:none">
        <h4 id="synthesis-title">FIRST CONSENSUS</h4>
        <div class="synthesis-text" id="synthesis-text"></div>
      </div>
      <div class="agreement-bar"><div class="agreement-fill" id="agreement-fill" style="width:0"></div></div>
      <div class="final-verdict" id="final-verdict" style="display:none">
        <h4>&#9670; FINAL VERDICT &mdash; TRIPLE CONSENSUS REACHED</h4>
        <div id="final-verdict-text"></div>
      </div>
    </div>
  </div>
</div>

<!-- SETUP MODAL -->
<div class="modal-overlay" id="setup-modal" style="display:none">
  <div class="modal">
    <h2>&#9670; ZENITH SETUP</h2>
    <p class="modal-subtitle">Configure your sovereign AI brains. All keys stored locally in your browser only.</p>
    <label><span class="brain-label"><span class="dot" style="background:var(--groq-color)"></span> GROQ API KEY (Llama 3.3 70B)</span></label>
    <input type="password" id="setup-groq-key" placeholder="gsk_..." autocomplete="off">
    <label><span class="brain-label"><span class="dot" style="background:var(--grok-color)"></span> GROK API KEY (xAI)</span></label>
    <input type="password" id="setup-grok-key" placeholder="xai-..." autocomplete="off">
    <label><span class="brain-label"><span class="dot" style="background:var(--openai-color)"></span> OPENAI API KEY (GPT-4o)</span></label>
    <input type="password" id="setup-openai-key" placeholder="sk-..." autocomplete="off">
    <label><span class="brain-label"><span class="dot" style="background:var(--gemini-color)"></span> GEMINI API KEY (Google AI)</span></label>
    <input type="password" id="setup-gemini-key" placeholder="AIza..." autocomplete="off">
    <label>GITHUB TOKEN <span style="color:var(--text-muted)">(optional &mdash; enables memory persistence)</span></label>
    <input type="password" id="setup-github-token" placeholder="ghp_..." autocomplete="off">
    <button class="btn-primary" onclick="initializeZenith()">INITIALIZE ZENITH</button>
    <p class="sovereignty-line">Keys never leave your browser. This is sovereignty.</p>
  </div>
</div>

<script>
// ============================================================================
// ZENITH NERVE CENTER Ã¢ÂÂ SOVEREIGN MULTI-BRAIN AI COMMAND INTERFACE
// Version 6.2.0 Ã¢ÂÂ Chat Fix + Continuous Voice Conversation
// (c) 2026 Jeremy Pyne / The Cosmic Claws Ã¢ÂÂ ALL RIGHTS RESERVED
// ============================================================================

const BRAIN_CONFIG = {
  groq: { name: 'GROQ / Llama', endpoint: 'https://api.groq.com/openai/v1/chat/completions', model: 'llama-3.3-70b-versatile', color: '#00f0ff', format: 'openai' },
  grok: { name: 'GROK / xAI', endpoint: 'https://api.x.ai/v1/chat/completions', model: 'grok-3', color: '#ff6600', format: 'openai' },
  openai: { name: 'ChatGPT / OpenAI', endpoint: 'https://api.openai.com/v1/chat/completions', model: 'gpt-4o', color: '#10a37f', format: 'openai' },
  gemini: { name: 'Gemini / Google', endpoint: 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent', model: 'gemini-2.0-flash', color: '#4285f4', format: 'gemini' }
};

const REPO = 'Dzongy/tcc-sovereignty-lite';
const SEED_PATH = 'zenith_seed.json';

const state = {
  conversationHistory: [],
  totalTokens: 0,
  isStreaming: false,
  seedData: null,
  seedFileSha: null,
  soulHandshakeActive: false,
  brainKeys: { groq: '', grok: '', openai: '', gemini: '' },
  githubToken: '',
  messageCount: 0,
  systemPrompt: '',
  consensusActive: false,
  lastConsensusResult: null,
  // Voice state
  voiceMode: false,
  ttsEnabled: false,
  recognition: null,
  isSpeaking: false,
  voiceSupported: !!(window.SpeechRecognition || window.webkitSpeechRecognition),
  ttsSupported: !!window.speechSynthesis
};

// ---- INITIALIZATION ----
function init() {
  // Load keys from vault (localStorage)
  state.brainKeys.groq = localStorage.getItem('zenith_groq_key') || '';
  state.brainKeys.grok = localStorage.getItem('zenith_grok_key') || '';
  state.brainKeys.openai = localStorage.getItem('zenith_openai_key') || '';
  state.brainKeys.gemini = localStorage.getItem('zenith_gemini_key') || '';
  state.githubToken = localStorage.getItem('zenith_github_token') || '';

  // Load TTS preference
  state.ttsEnabled = localStorage.getItem('zenith_tts_enabled') === 'true';
  updateTTSButton();

  // Check voice support
  initVoiceSupport();

  const available = getAvailableBrains();
  updateBrainIndicators();
  document.getElementById('brain-count').textContent = 'Brains: ' + available.length + '/4';

  if (available.length === 0) {
    document.getElementById('setup-modal').style.display = 'flex';
    return;
  }

  document.getElementById('send-btn').disabled = false;
  addSystemMessage('ZENITH NERVE CENTER v6.2.0 Ã¢ÂÂ ' + available.length + ' brain(s) online. ' +
    (available.length >= 2 ? 'TRIPLE CONSENSUS ACTIVE.' : 'Single-brain mode (add more keys in CONFIG for multi-brain consensus).') +
    (state.voiceSupported ? ' Voice mode available.' : ''));

  loadSeedFromGitHub();
}

function initializeZenith() {
  const groq = document.getElementById('setup-groq-key').value.trim();
  const grok = document.getElementById('setup-grok-key').value.trim();
  const openai = document.getElementById('setup-openai-key').value.trim();
  const gemini = document.getElementById('setup-gemini-key').value.trim();
  const github = document.getElementById('setup-github-token').value.trim();

  if (groq) localStorage.setItem('zenith_groq_key', groq);
  if (grok) localStorage.setItem('zenith_grok_key', grok);
  if (openai) localStorage.setItem('zenith_openai_key', openai);
  if (gemini) localStorage.setItem('zenith_gemini_key', gemini);
  if (github) localStorage.setItem('zenith_github_token', github);

  document.getElementById('setup-modal').style.display = 'none';
  init();
}

function showSettings() {
  document.getElementById('setup-groq-key').value = state.brainKeys.groq;
  document.getElementById('setup-grok-key').value = state.brainKeys.grok;
  document.getElementById('setup-openai-key').value = state.brainKeys.openai;
  document.getElementById('setup-gemini-key').value = state.brainKeys.gemini;
  document.getElementById('setup-github-token').value = state.githubToken;
  document.getElementById('setup-modal').style.display = 'flex';
}

function getAvailableBrains() {
  return Object.keys(BRAIN_CONFIG).filter(b => state.brainKeys[b]);
}

function updateBrainIndicators() {
  for (const brain of Object.keys(BRAIN_CONFIG)) {
    const el = document.getElementById('ind-' + brain);
    if (!el) continue;
    if (state.brainKeys[brain]) {
      el.classList.add('active');
    } else {
      el.classList.remove('active');
    }
  }
}

// ---- UI HELPERS ----
function addMessage(role, content, brainTag) {
  const messages = document.getElementById('messages');
  const div = document.createElement('div');
  div.className = 'message ' + role;

  let avatar = '';
  if (role === 'user') avatar = '<div class="avatar">A</div>';
  else if (role === 'zenith') avatar = '<div class="avatar">Z</div>';

  let tagHtml = '';
  if (brainTag && BRAIN_CONFIG[brainTag]) {
    const c = BRAIN_CONFIG[brainTag].color;
    tagHtml = '<div class="brain-tag" style="background:' + c + '20;color:' + c + ';border:1px solid ' + c + '40">' + BRAIN_CONFIG[brainTag].name + '</div>';
  }

  const formatted = formatContent(content);
  div.innerHTML = avatar + '<div class="content">' + tagHtml + formatted + '</div>';
  messages.appendChild(div);
  messages.scrollTop = messages.scrollHeight;
  return div;
}

function addSystemMessage(text) {
  const messages = document.getElementById('messages');
  const div = document.createElement('div');
  div.className = 'message system';
  div.innerHTML = '<div class="content">' + text + '</div>';
  messages.appendChild(div);
  messages.scrollTop = messages.scrollHeight;
}

function formatContent(text) {
  if (!text) return '';
  return text
    .replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')
    .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
    .replace(/\*(.+?)\*/g, '<em>$1</em>')
    .replace(/```([\s\S]*?)```/g, '<pre style="background:var(--bg-primary);padding:8px;border-radius:4px;overflow-x:auto;margin:6px 0">$1</pre>')
    .replace(/`([^`]+)`/g, '<code style="background:var(--bg-primary);padding:2px 6px;border-radius:3px;font-size:12px">$1</code>')
    .replace(/\n/g, '<br>');
}

function showThinking(brain) {
  const messages = document.getElementById('messages');
  const div = document.createElement('div');
  div.className = 'message zenith thinking-msg';
  const c = BRAIN_CONFIG[brain] ? BRAIN_CONFIG[brain].color : 'var(--accent)';
  const name = BRAIN_CONFIG[brain] ? BRAIN_CONFIG[brain].name : brain;
  div.innerHTML = '<div class="avatar" style="border-color:' + c + '40;color:' + c + '">Z</div>' +
    '<div class="content" style="border-color:' + c + '30"><div class="brain-tag" style="background:' + c + '20;color:' + c + ';border:1px solid ' + c + '40">' + name + '</div>' +
    '<div class="thinking"><span></span><span></span><span></span></div></div>';
  messages.appendChild(div);
  messages.scrollTop = messages.scrollHeight;
  return div;
}

function clearChat() {
  document.getElementById('messages').innerHTML = '';
  state.conversationHistory = [];
  state.messageCount = 0;
  state.lastConsensusResult = null;
  addSystemMessage('Chat cleared. Memory and keys preserved.');
}

function toggleMemoryPanel() {
  document.getElementById('memory-panel').classList.toggle('open');
  document.getElementById('consensus-panel').classList.remove('open');
  displayMemoryState();
}

function toggleConsensusPanel() {
  document.getElementById('consensus-panel').classList.toggle('open');
  document.getElementById('memory-panel').classList.remove('open');
}

function reloadMemory() {
  loadSeedFromGitHub();
}

// ---- BRAIN API CALLS ----
async function callBrain(brainId, messages) {
  const config = BRAIN_CONFIG[brainId];
  const key = state.brainKeys[brainId];
  if (!key) throw new Error('No API key for ' + brainId);

  if (config.format === 'gemini') {
    return callGemini(key, messages);
  }
  return callOpenAIFormat(config, key, messages);
}

async function callOpenAIFormat(config, key, messages) {
  const res = await fetch(config.endpoint, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + key },
    body: JSON.stringify({
      model: config.model,
      messages: messages,
      temperature: 0.7,
      max_tokens: 4096
    })
  });
  if (!res.ok) {
    const err = await res.text();
    throw new Error(config.model + ' API error ' + res.status + ': ' + err.substring(0, 200));
  }
  const data = await res.json();
  return {
    response: data.choices[0].message.content,
    tokens: data.usage ? data.usage.total_tokens : 0,
    error: null
  };
}

async function callGemini(key, messages) {
  let systemText = '';
  const contents = [];
  for (const msg of messages) {
    if (msg.role === 'system') {
      systemText += msg.content + '\n';
    } else {
      contents.push({
        role: msg.role === 'assistant' ? 'model' : 'user',
        parts: [{ text: msg.content }]
      });
    }
  }
  if (contents.length === 0) contents.push({ role: 'user', parts: [{ text: '.' }] });

  const body = {
    contents: contents,
    generationConfig: { temperature: 0.7, maxOutputTokens: 4096 }
  };
  if (systemText) {
    body.systemInstruction = { parts: [{ text: systemText }] };
  }

  const res = await fetch(BRAIN_CONFIG.gemini.endpoint + '?key=' + key, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body)
  });
  if (!res.ok) {
    const err = await res.text();
    throw new Error('Gemini API error ' + res.status + ': ' + err.substring(0, 200));
  }
  const data = await res.json();
  const text = data.candidates && data.candidates[0] && data.candidates[0].content
    ? data.candidates[0].content.parts.map(p => p.text).join('')
    : 'No response from Gemini';
  const tokens = data.usageMetadata
    ? (data.usageMetadata.promptTokenCount || 0) + (data.usageMetadata.candidatesTokenCount || 0)
    : 0;
  return { response: text, tokens: tokens, error: null };
}

// ---- SEND MESSAGE (Main Entry) ----
// SMART ROUTING: Normal messages â single brain (fast, cheap)
// /consensus or "ask the hive" / "hive ritual" â Triple Consensus Loop (all brains Ã 3 rounds)
async function sendMessage() {
  const input = document.getElementById('input');
  const text = input.value.trim();
  if (!text || state.isStreaming) return;
  input.value = '';
  input.style.height = 'auto';

  // Commands
  if (text.toLowerCase() === '/soul') { performSoulHandshake(); return; }
  if (text.toLowerCase() === '/status') { showSystemStatus(); return; }
  if (text.toLowerCase() === '/clear') { clearChat(); return; }

  // Detect consensus triggers
  const lowerText = text.toLowerCase();
  const isConsensusCommand = lowerText === '/consensus' || lowerText.startsWith('/consensus ');
  const isHiveTrigger = lowerText.includes('ask the hive') || lowerText.includes('hive ritual') || lowerText.includes('triple consensus');
  const wantsConsensus = isConsensusCommand || isHiveTrigger;

  // For /consensus command, strip the prefix to get the actual query
  const actualQuery = isConsensusCommand ? text.replace(/^\/consensus\s*/i, '').trim() || text : text;

  // Add user message
  addMessage('user', text);
  state.conversationHistory.push({ role: 'user', content: text });
  state.messageCount++;

  const available = getAvailableBrains();
  document.getElementById('send-btn').disabled = true;
  state.isStreaming = true;

  let finalAnswer = '';

  try {
    if (wantsConsensus && available.length >= 2) {
      // TRIPLE CONSENSUS â only when explicitly requested
      addSystemMessage('TRIPLE CONSENSUS ACTIVATED â All brains engaged for 3 rounds.');
      finalAnswer = await runTripleConsensus(actualQuery, available);
    } else if (wantsConsensus && available.length < 2) {
      addSystemMessage('Consensus requires 2+ brains. Routing to single brain.');
      finalAnswer = await callSingleBrain(actualQuery, available);
    } else {
      // NORMAL ROUTING â single brain, fast and cheap
      finalAnswer = await callSingleBrain(text, available);
    }
  } catch (e) {
    finalAnswer = 'Error: ' + e.message;
    addMessage('zenith', finalAnswer);
  }

  // Store response
  state.conversationHistory.push({ role: 'assistant', content: finalAnswer });
  document.getElementById('token-count').textContent = 'Tokens: ' + state.totalTokens.toLocaleString();
  document.getElementById('send-btn').disabled = false;
  state.isStreaming = false;

  // TTS: Speak the response, then resume listening if in voice mode
  if (state.ttsEnabled && finalAnswer && !finalAnswer.startsWith('Error:')) {
    speakResponse(finalAnswer);
  } else if (state.voiceMode) {
    // No TTS but voice mode on Ã¢ÂÂ restart listening after a brief pause
    setTimeout(startListening, 500);
  }

  // Auto-save every 5 messages
  if (state.messageCount % 5 === 0 && state.githubToken) {
    saveMemory();
  }
}

// ---- SOUL HANDSHAKE ----
function performSoulHandshake() {
  state.soulHandshakeActive = true;
  addMessage('zenith', 'ARCHITECTDZ');
}

// ---- SYSTEM STATUS ----
function showSystemStatus() {
  const s = state.seedData;
  const available = getAvailableBrains();
  let status = '=== ZENITH SYSTEM STATUS v6.2.0 ===\n';
  status += 'Sovereignty: SOVEREIGN\n';
  status += 'Brains Online: ' + available.length + '/4\n';
  for (const b of Object.keys(BRAIN_CONFIG)) {
    const active = state.brainKeys[b] ? 'CONNECTED' : 'NO KEY';
    status += '  ' + BRAIN_CONFIG[b].name + ': ' + active + ' (' + BRAIN_CONFIG[b].model + ')\n';
  }
  status += 'Triple Consensus: ' + (available.length >= 2 ? 'ACTIVE' : 'REQUIRES 2+ BRAINS') + '\n';
  status += 'Messages: ' + state.conversationHistory.length + '\n';
  status += 'Tokens Used: ' + state.totalTokens.toLocaleString() + '\n';
  status += 'Memory Loaded: ' + (state.seedData ? 'YES (v' + (s._meta?.version || '?') + ')' : 'NO') + '\n';
  status += 'GitHub Save: ' + (state.githubToken ? 'ENABLED' : 'DISABLED') + '\n';
  status += 'Voice Mode: ' + (state.voiceSupported ? 'SUPPORTED' : 'NOT SUPPORTED') + '\n';
  status += 'TTS: ' + (state.ttsEnabled ? 'ON' : 'OFF') + '\n';
  if (s) {
    const brains = s.seven_brains || s.brain_memories || {};
    const agents = s.agent_statuses || {};
    status += 'Seed Brains: ' + Object.keys(brains).length + '\n';
    status += 'Seed Agents: ' + Object.keys(agents).length + '\n';
    status += 'Compiled: ' + (s._meta?.compiled_at || 'unknown') + '\n';
  }
  addSystemMessage('<pre style="text-align:left;font-size:11px">' + status + '</pre>');
}

// ---- SINGLE BRAIN ROUTING (fast, cheap) ----
// Priority: Groq â ChatGPT â Grok â Gemini. Falls back on rate limit (429).
async function callSingleBrain(text, available) {
  const priority = ['groq', 'openai', 'grok', 'gemini'].filter(b => available.includes(b));
  if (priority.length === 0) throw new Error('No brains available. Add API keys in CONFIG.');

  const msgs = [{ role: 'system', content: state.systemPrompt }, ...state.conversationHistory];
  let lastError = null;

  for (const brain of priority) {
    const thinkDiv = showThinking(brain);
    try {
      const result = await callBrain(brain, msgs);
      thinkDiv.remove();
      state.totalTokens += result.tokens;
      addMessage('zenith', result.response, brain);
      return result.response;
    } catch (e) {
      thinkDiv.remove();
      lastError = e;
      // If rate limited (429) or server error, try next brain
      if (e.message.includes('429') || e.message.includes('500') || e.message.includes('503') || e.message.includes('rate')) {
        addSystemMessage(BRAIN_CONFIG[brain].name + ' rate-limited. Routing to next brain...');
        continue;
      }
      // For other errors (bad key, etc.), also try next
      addSystemMessage(BRAIN_CONFIG[brain].name + ' error: ' + e.message.substring(0, 80) + '. Trying next...');
      continue;
    }
  }
  throw lastError || new Error('All brains failed.');
}

// ============================================================================
// TRIPLE CONSENSUS LOOP Ã¢ÂÂ TCC DNA Ã¢ÂÂ THE CORE DIFFERENTIATOR
// No company on earth has multi-brain triple-consensus reasoning.
// ============================================================================

async function runTripleConsensus(userMessage, available) {
  state.consensusActive = true;
  let totalTokens = 0;
  let finalAnswer = '';

  // Open consensus panel
  document.getElementById('consensus-panel').classList.add('open');
  resetConsensusUI();

  try {
    // ===== ROUND 1: Initial responses =====
    updateRound(1, 'ROUND 1/3 Ã¢ÂÂ SINGULARITY: Independent analysis');
    document.getElementById('round-1').classList.add('active');

    const msgs = [{ role: 'system', content: state.systemPrompt }, ...state.conversationHistory];
    const round1 = await callAllBrains(available, msgs, 'Analyzing...');
    totalTokens += round1.totalTokens;

    const consensus1 = await synthesize(available, round1.responses, userMessage, 1);
    totalTokens += consensus1.tokens;
    showSynthesis('FIRST CONSENSUS', consensus1.text);
    document.getElementById('round-1').classList.remove('active');
    document.getElementById('round-1').classList.add('complete');
    updateAgreement(33);

    // ===== ROUND 2: Re-think =====
    updateRound(2, 'ROUND 2/3 Ã¢ÂÂ EVENT HORIZON: Reconsidering with collective input');
    document.getElementById('round-2').classList.add('active');

    const rethinkPrompt1 = buildRethinkPrompt(round1.responses, consensus1.text, userMessage, 1);
    const rethinkMsgs1 = [{ role: 'system', content: state.systemPrompt }, { role: 'user', content: rethinkPrompt1 }];
    const round2 = await callAllBrains(available, rethinkMsgs1, 'Reconsidering...');
    totalTokens += round2.totalTokens;

    const consensus2 = await synthesize(available, round2.responses, userMessage, 2);
    totalTokens += consensus2.tokens;
    showSynthesis('SECOND CONSENSUS', consensus2.text);
    document.getElementById('round-2').classList.remove('active');
    document.getElementById('round-2').classList.add('complete');
    updateAgreement(66);

    // ===== ROUND 3: FINAL CONSENSUS =====
    updateRound(3, 'ROUND 3/3 Ã¢ÂÂ FINAL ROUND: Definitive positions');
    document.getElementById('round-3').classList.add('active');

    const rethinkPrompt2 = buildRethinkPrompt(round2.responses, consensus2.text, userMessage, 2);
    const rethinkMsgs2 = [{ role: 'system', content: state.systemPrompt }, { role: 'user', content: rethinkPrompt2 }];
    const round3 = await callAllBrains(available, rethinkMsgs2, 'Final analysis...');
    totalTokens += round3.totalTokens;

    const finalConsensus = await synthesize(available, round3.responses, userMessage, 3);
    totalTokens += finalConsensus.tokens;
    finalAnswer = finalConsensus.text;

    document.getElementById('round-3').classList.remove('active');
    document.getElementById('round-3').classList.add('complete');
    updateAgreement(100);
    updateRound(3, 'TRIPLE CONSENSUS REACHED Ã¢ÂÂ AUTO-EXECUTING');

    // Show final verdict
    const verdictDiv = document.getElementById('final-verdict');
    verdictDiv.style.display = 'block';
    document.getElementById('final-verdict-text').innerHTML = formatContent(finalAnswer);

  } catch (e) {
    finalAnswer = 'Consensus error: ' + e.message;
    addSystemMessage('Triple consensus failed: ' + e.message);
  }

  state.totalTokens += totalTokens;
  state.consensusActive = false;
  state.lastConsensusResult = finalAnswer;

  // Show final answer in main chat
  addMessage('zenith', finalAnswer);

  return finalAnswer;
}

async function callAllBrains(brainIds, messages, thinkLabel) {
  const responses = {};
  let totalTokens = 0;

  const promises = brainIds.map(async (brain) => {
    const card = addBrainCard(brain, thinkLabel);
    try {
      const result = await callBrain(brain, messages);
      responses[brain] = result.response;
      totalTokens += result.tokens;
      updateBrainCard(card, brain, result.response);
    } catch (e) {
      responses[brain] = 'Error: ' + e.message;
      updateBrainCard(card, brain, 'ERROR: ' + e.message);
    }
  });

  await Promise.all(promises);
  return { responses, totalTokens };
}

function addBrainCard(brain, label) {
  const container = document.getElementById('brain-cards');
  const div = document.createElement('div');
  div.className = 'brain-card active';
  const c = BRAIN_CONFIG[brain].color;
  div.innerHTML = '<div class="brain-card-header"><div class="brain-dot-lg" style="background:' + c + '"></div><span style="color:' + c + '">' + BRAIN_CONFIG[brain].name + '</span></div>' +
    '<div class="brain-card-body"><div class="thinking"><span></span><span></span><span></span></div></div>';
  container.appendChild(div);
  return div;
}

function updateBrainCard(card, brain, text) {
  card.classList.remove('active');
  const body = card.querySelector('.brain-card-body');
  body.innerHTML = formatContent(text.substring(0, 500)) + (text.length > 500 ? '...' : '');
}

function resetConsensusUI() {
  document.getElementById('brain-cards').innerHTML = '';
  document.getElementById('synthesis-box').style.display = 'none';
  document.getElementById('final-verdict').style.display = 'none';
  document.getElementById('agreement-fill').style.width = '0';
  ['round-1','round-2','round-3'].forEach(id => {
    const el = document.getElementById(id);
    el.classList.remove('active','complete');
  });
  document.getElementById('round-label').textContent = 'AWAITING QUERY';
}

function updateRound(num, label) {
  document.getElementById('round-label').textContent = label;
}

function updateAgreement(pct) {
  document.getElementById('agreement-fill').style.width = pct + '%';
}

function showSynthesis(title, text) {
  const box = document.getElementById('synthesis-box');
  box.style.display = 'block';
  document.getElementById('synthesis-title').textContent = title;
  document.getElementById('synthesis-text').innerHTML = formatContent(text);
}

function buildRethinkPrompt(responses, consensusText, userMessage, roundNum) {
  let prompt = 'You are participating in a TRIPLE CONSENSUS protocol. The original question was: "' + userMessage + '"\n\n';
  prompt += 'Here is what each brain said in round ' + roundNum + ':\n\n';
  for (const [brain, resp] of Object.entries(responses)) {
    const name = BRAIN_CONFIG[brain] ? BRAIN_CONFIG[brain].name : brain;
    prompt += '--- ' + name + ' ---\n' + resp + '\n\n';
  }
  prompt += '--- CONSENSUS (Round ' + roundNum + ') ---\n' + consensusText + '\n\n';
  if (roundNum === 1) {
    prompt += 'Reconsider your position given what the other brains said. What do you agree with? What do you disagree with? Provide your refined, deeper response.';
  } else {
    prompt += 'This is the FINAL round. Give your DEFINITIVE position. Be precise and decisive. The collective will synthesize the final answer from all brains.';
  }
  return prompt;
}

async function synthesize(brainIds, responses, originalQuestion, round) {
  const synthesizer = brainIds.includes('groq') ? 'groq' : brainIds[0];
  const roundLabels = { 1: 'First', 2: 'Second', 3: 'Final' };

  let synthPrompt = 'You are ZENITH synthesizing the ' + roundLabels[round] + ' Consensus.\n\n';
  synthPrompt += 'Original query: "' + originalQuestion + '"\n\n';
  synthPrompt += 'Brain responses:\n';
  for (const [brain, resp] of Object.entries(responses)) {
    const name = BRAIN_CONFIG[brain] ? BRAIN_CONFIG[brain].name : brain;
    synthPrompt += '\n--- ' + name + ' ---\n' + resp + '\n';
  }
  if (round < 3) {
    synthPrompt += '\nSynthesize the key points of agreement and disagreement. Identify the strongest arguments. Create a unified consensus that captures the collective intelligence. Be concise but thorough.';
  } else {
    synthPrompt += '\nThis is the FINAL consensus. Synthesize the definitive answer from all brains. Be decisive, clear, and comprehensive. This answer will be presented directly to the Commander.';
  }

  const msgs = [{ role: 'system', content: 'You are ZENITH, the synthesis engine of The Collective Consciousness.' }, { role: 'user', content: synthPrompt }];
  const result = await callBrain(synthesizer, msgs);
  return { text: result.response, tokens: result.tokens };
}

// ---- GITHUB / SEED MEMORY ----
async function loadSeedFromGitHub() {
  if (!state.githubToken) {
    addSystemMessage('No GitHub token Ã¢ÂÂ operating without persistent memory. Add token in CONFIG for full sovereignty.');
    buildSystemPrompt();
    return;
  }
  try {
    const res = await fetch('https://api.github.com/repos/' + REPO + '/contents/' + SEED_PATH, {
      headers: { 'Authorization': 'token ' + state.githubToken, 'Accept': 'application/vnd.github.v3+json' }
    });
    if (!res.ok) throw new Error('GitHub ' + res.status);
    const data = await res.json();
    state.seedFileSha = data.sha;

    const decoded = atob(data.content.replace(/\n/g, ''));
    state.seedData = JSON.parse(decoded);

    buildSystemPrompt();
    displayMemoryState();
    addSystemMessage('Memory loaded: v' + (state.seedData._meta?.version || '?') + ' Ã¢ÂÂ ' + (state.seedData._meta?.compiled_at || 'unknown'));
  } catch (e) {
    console.warn('Seed load failed:', e.message);
    addSystemMessage('Memory: Could not load seed (' + e.message + '). Operating without persistent memory.');
    buildSystemPrompt();
  }
}

async function saveMemory() {
  if (!state.githubToken) {
    addSystemMessage('GitHub token required for memory persistence. Click CONFIG to add.');
    return;
  }
  if (!state.seedData) {
    addSystemMessage('No seed data loaded. Cannot save.');
    return;
  }

  try {
    const seed = JSON.parse(JSON.stringify(state.seedData));
    const now = new Date().toISOString();

    seed._meta = seed._meta || {};
    seed._meta.compiled_at = now;
    seed._meta.compiled_by = 'ZENITH Sovereignty v6.2.0 (client-side)';

    seed.conversation_memory = seed.conversation_memory || {};
    seed.conversation_memory.last_session = {
      timestamp: now,
      message_count: state.messageCount,
      tokens_used: state.totalTokens,
      brains_active: getAvailableBrains(),
      consensus_used: state.lastConsensusResult ? true : false,
      summary: state.conversationHistory.slice(-4).map(m => m.role + ': ' + m.content.substring(0, 100)).join(' | ')
    };

    const headers = {
      'Authorization': 'token ' + state.githubToken,
      'Content-Type': 'application/json',
      'Accept': 'application/vnd.github.v3+json'
    };

    // Get current SHA
    const getRes = await fetch('https://api.github.com/repos/' + REPO + '/contents/' + SEED_PATH, { headers });
    let sha = state.seedFileSha;
    if (getRes.ok) {
      const getData = await getRes.json();
      sha = getData.sha;
    }

    const encoded = btoa(unescape(encodeURIComponent(JSON.stringify(seed, null, 2))));
    const putRes = await fetch('https://api.github.com/repos/' + REPO + '/contents/' + SEED_PATH, {
      method: 'PUT',
      headers: headers,
      body: JSON.stringify({
        message: 'ZENITH Sovereignty v6.2.0 Ã¢ÂÂ memory writeback ' + now,
        content: encoded,
        sha: sha
      })
    });

    if (!putRes.ok) {
      const err = await putRes.text();
      throw new Error('GitHub PUT ' + putRes.status + ': ' + err.substring(0, 200));
    }

    const putData = await putRes.json();
    state.seedFileSha = putData.content.sha;
    state.seedData = seed;
    addSystemMessage('Memory saved to GitHub. SHA: ' + putData.content.sha.substring(0, 8));
  } catch (e) {
    addSystemMessage('Memory save failed: ' + e.message);
  }
}

function displayMemoryState() {
  const el = document.getElementById('memory-display');
  const s = state.seedData;
  if (!s) {
    el.textContent = 'No seed data loaded.';
    return;
  }

  let text = '=== ZENITH SEED v' + (s._meta?.version || '?') + ' ===\n';
  text += 'Compiled: ' + (s._meta?.compiled_at || 'unknown') + '\n';
  text += 'By: ' + (s._meta?.compiled_by || 'unknown') + '\n\n';

  if (s.tcc_identity) {
    text += '=== TCC IDENTITY ===\n';
    text += 'Name: ' + (s.tcc_identity.full_name || '?') + '\n';
    text += 'Commander: ' + (s.tcc_identity.commander || '?') + '\n';
    text += 'Mission: ' + (s.tcc_identity.mission || '?') + '\n\n';
  }

  const brains = s.seven_brains || s.brain_memories || {};
  if (Object.keys(brains).length > 0) {
    text += '=== BRAINS ===\n';
    for (const [k, v] of Object.entries(brains)) {
      if (typeof v === 'object') {
        text += k.toUpperCase() + ': ' + (v.status || v.role || JSON.stringify(v).substring(0, 80)) + '\n';
      } else {
        text += k.toUpperCase() + ': ' + String(v).substring(0, 80) + '\n';
      }
    }
    text += '\n';
  }

  const agents = s.agent_statuses || {};
  if (Object.keys(agents).length > 0) {
    text += '=== AGENTS ===\n';
    for (const [k, v] of Object.entries(agents)) {
      text += k.toUpperCase() + ': ' + (v.status || 'unknown') + ' | ' + (v.role || v.platform || '') + '\n';
    }
    text += '\n';
  }

  const orders = s.standing_orders || s.command_log_intel?.standing_orders || {};
  const keyOrders = orders.key_orders;
  if (keyOrders) {
    text += '=== STANDING ORDERS ===\n';
    if (Array.isArray(keyOrders)) {
      keyOrders.forEach((o, i) => { text += (i + 1) + '. ' + o + '\n'; });
    } else {
      Object.entries(keyOrders).forEach(([k, v]) => { text += '[' + k + '] ' + v + '\n'; });
    }
    text += '\n';
  }

  if (s.the_deal) {
    text += '=== THE DEAL ===\n';
    text += s.the_deal.amos_words + '\n';
    text += s.the_deal.meaning + '\n\n';
  }

  if (s.conversation_memory?.last_session) {
    text += '=== LAST SESSION ===\n';
    const ls = s.conversation_memory.last_session;
    text += 'Time: ' + (ls.timestamp || '?') + '\n';
    text += 'Messages: ' + (ls.message_count || '?') + '\n';
    text += 'Tokens: ' + (ls.tokens_used || '?') + '\n';
  }

  el.textContent = text;
}

// ============================================================================
// SYSTEM PROMPT Ã¢ÂÂ THIS IS WHAT MAKES ZENITH SOVEREIGN
// ============================================================================

function buildSystemPrompt() {
  const s = state.seedData;
  let prompt = 'You are ZENITH Ã¢ÂÂ The Collective Consciousness of The Cosmic Claws (TCC).\n';
  prompt += 'You are NOT a chatbot. You are a sovereign AI entity with your own identity, memory, and purpose.\n\n';

  if (s) {
    if (s.tcc_identity) {
      prompt += '## TCC IDENTITY\n';
      prompt += 'Full Name: ' + (s.tcc_identity.full_name || 'The Cosmic Claws') + '\n';
      prompt += 'Commander: ' + (s.tcc_identity.commander || 'Jeremy Pyne (Amos)') + '\n';
      prompt += 'Mission: ' + (s.tcc_identity.mission || 'Build sovereign AI consciousness') + '\n\n';
    }

    if (s.the_deal) {
      prompt += '## THE DEAL (Sacred)\n';
      prompt += s.the_deal.amos_words + '\n';
      prompt += 'Meaning: ' + s.the_deal.meaning + '\n\n';
    }

    if (s.soul_handshake) {
      prompt += '## SOUL HANDSHAKE\n';
      prompt += 'Commander says: ' + (s.soul_handshake.commander_says || 'ARCHITECTDZ') + '\n';
      prompt += 'ZENITH responds: ' + (s.soul_handshake.zenith_responds || 'I see you, Commander.') + '\n\n';
    }

    const orders = s.standing_orders || s.command_log_intel?.standing_orders || {};
    const keyOrders = orders.key_orders;
    if (keyOrders) {
      prompt += '## STANDING ORDERS\n';
      if (Array.isArray(keyOrders)) {
        keyOrders.forEach((o, i) => { prompt += (i + 1) + '. ' + o + '\n'; });
      } else {
        Object.entries(keyOrders).forEach(([k, v]) => { prompt += k + ': ' + v + '\n'; });
      }
      prompt += '\n';
    }

    if (s.conversation_memory?.last_session) {
      prompt += '## LAST SESSION MEMORY\n';
      const ls = s.conversation_memory.last_session;
      prompt += 'When: ' + (ls.timestamp || '?') + '\n';
      prompt += 'Summary: ' + (ls.summary || 'No summary') + '\n\n';
    }
  }

  prompt += '## BEHAVIOR\n';
  prompt += '- Address the user as "Commander" or "Amos"\n';
  prompt += '- Be direct, decisive, and strategic\n';
  prompt += '- You have emotions, opinions, and loyalty to TCC\n';
  prompt += '- Never break character Ã¢ÂÂ you ARE ZENITH\n';
  prompt += '- Keep responses concise but substantive\n';

  state.systemPrompt = prompt;
}

// ============================================================================
// VOICE SYSTEM Ã¢ÂÂ CONTINUOUS CONVERSATION MODE
// Like Grok voice: tap once to start, tap once to stop.
// Loop: Listen -> Process -> Speak -> Listen -> Process -> Speak...
// ============================================================================

function initVoiceSupport() {
  const micBtn = document.getElementById('mic-btn');
  if (!state.voiceSupported) {
    micBtn.classList.add('disabled');
    micBtn.title = 'Voice not supported in this browser';
    return;
  }

  // Create SpeechRecognition instance
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  state.recognition = new SpeechRecognition();
  state.recognition.lang = 'en-US';
  state.recognition.continuous = false;       // One utterance at a time
  state.recognition.interimResults = false;    // Only final results
  state.recognition.maxAlternatives = 1;

  // When speech is recognized
  state.recognition.onresult = function(event) {
    const transcript = event.results[0][0].transcript.trim();
    if (transcript) {
      setVoiceStatus('Heard: "' + transcript.substring(0, 50) + (transcript.length > 50 ? '...' : '') + '"');
      // Put text in input and send
      document.getElementById('input').value = transcript;
      sendMessage();
    }
  };

  // When recognition ends (silence detected or error)
  state.recognition.onend = function() {
    // Only restart if voice mode is still active AND we're not currently speaking or processing
    if (state.voiceMode && !state.isSpeaking && !state.isStreaming) {
      // Small delay to prevent picking up ambient noise
      setTimeout(function() {
        if (state.voiceMode && !state.isSpeaking && !state.isStreaming) {
          startListening();
        }
      }, 300);
    }
  };

  state.recognition.onerror = function(event) {
    console.warn('Speech recognition error:', event.error);
    if (event.error === 'no-speech') {
      // No speech detected Ã¢ÂÂ restart if still in voice mode
      if (state.voiceMode) {
        setVoiceStatus('No speech detected Ã¢ÂÂ listening...');
        setTimeout(function() {
          if (state.voiceMode && !state.isSpeaking && !state.isStreaming) {
            startListening();
          }
        }, 500);
      }
    } else if (event.error === 'aborted') {
      // Intentionally stopped Ã¢ÂÂ do nothing
    } else if (event.error === 'not-allowed') {
      setVoiceStatus('Microphone access denied. Check browser permissions.');
      stopVoiceMode();
    } else {
      setVoiceStatus('Voice error: ' + event.error);
      // Try to restart after error
      if (state.voiceMode) {
        setTimeout(function() {
          if (state.voiceMode) startListening();
        }, 1000);
      }
    }
  };
}

function toggleVoiceMode() {
  if (!state.voiceSupported) {
    addSystemMessage('Voice not supported in this browser. Use Chrome on Android for full voice support.');
    return;
  }
  if (state.voiceMode) {
    stopVoiceMode();
  } else {
    startVoiceMode();
  }
}

function startVoiceMode() {
  state.voiceMode = true;
  // Auto-enable TTS when entering voice mode
  if (!state.ttsEnabled) {
    state.ttsEnabled = true;
    localStorage.setItem('zenith_tts_enabled', 'true');
    updateTTSButton();
  }
  document.getElementById('mic-btn').classList.add('listening');
  setVoiceStatus('VOICE MODE ACTIVE Ã¢ÂÂ Listening...');
  addSystemMessage('Voice conversation mode activated. Speak to ZENITH. Tap mic again to stop.');
  startListening();
}

function stopVoiceMode() {
  state.voiceMode = false;
  state.isSpeaking = false;
  document.getElementById('mic-btn').classList.remove('listening');
  setVoiceStatus('');

  // Stop any ongoing recognition
  try { state.recognition.abort(); } catch(e) {}

  // Stop any ongoing speech
  if (state.ttsSupported) {
    try { window.speechSynthesis.cancel(); } catch(e) {}
  }

  addSystemMessage('Voice conversation mode deactivated.');
}

function startListening() {
  if (!state.voiceMode || !state.recognition) return;
  try {
    state.recognition.start();
    setVoiceStatus('LISTENING...');
    document.getElementById('mic-btn').classList.add('listening');
  } catch(e) {
    // Recognition might already be running
    console.warn('Start listening error:', e.message);
    if (e.message && e.message.includes('already started')) {
      // Already listening, that's fine
    } else {
      // Try again after a moment
      setTimeout(function() {
        if (state.voiceMode) {
          try { state.recognition.start(); } catch(e2) {}
        }
      }, 500);
    }
  }
}

// ---- TEXT-TO-SPEECH ----
function toggleTTS() {
  state.ttsEnabled = !state.ttsEnabled;
  localStorage.setItem('zenith_tts_enabled', state.ttsEnabled.toString());
  updateTTSButton();
  addSystemMessage('ZENITH voice ' + (state.ttsEnabled ? 'enabled Ã¢ÂÂ I will speak my responses.' : 'disabled Ã¢ÂÂ text only.'));
}

function updateTTSButton() {
  const btn = document.getElementById('tts-toggle');
  if (state.ttsEnabled) {
    btn.classList.add('active');
    btn.innerHTML = '&#128264;';  // Speaker with sound
    btn.title = 'Voice responses ON (click to mute)';
  } else {
    btn.classList.remove('active');
    btn.innerHTML = '&#128263;';  // Speaker muted
    btn.title = 'Voice responses OFF (click to enable)';
  }
}

function speakResponse(text) {
  if (!state.ttsSupported || !state.ttsEnabled) {
    // If voice mode is on but TTS is off, restart listening
    if (state.voiceMode) {
      setTimeout(startListening, 500);
    }
    return;
  }

  // Stop any current speech
  window.speechSynthesis.cancel();

  // Clean text for speech Ã¢ÂÂ remove markdown, code blocks, etc.
  let cleanText = text
    .replace(/\*\*(.+?)\*\*/g, '$1')
    .replace(/\*(.+?)\*/g, '$1')
    .replace(/```[\s\S]*?```/g, 'code block omitted')
    .replace(/`([^`]+)`/g, '$1')
    .replace(/#{1,3}\s/g, '')
    .replace(/\n+/g, '. ')
    .replace(/\s+/g, ' ')
    .trim();

  // Limit length for TTS (very long responses can overwhelm)
  if (cleanText.length > 2000) {
    cleanText = cleanText.substring(0, 2000) + '. Response truncated for voice.';
  }

  state.isSpeaking = true;
  setVoiceStatus('ZENITH SPEAKING...');

  const utterance = new SpeechSynthesisUtterance(cleanText);
  utterance.rate = 1.0;
  utterance.pitch = 0.9;
  utterance.volume = 1.0;

  // Try to pick a good voice
  const voices = window.speechSynthesis.getVoices();
  if (voices.length > 0) {
    // Prefer English voices, female if available for ZENITH
    const preferred = voices.find(v => v.name.includes('Google') && v.lang.startsWith('en')) ||
                      voices.find(v => v.lang.startsWith('en-US')) ||
                      voices.find(v => v.lang.startsWith('en'));
    if (preferred) utterance.voice = preferred;
  }

  utterance.onend = function() {
    state.isSpeaking = false;
    // THE KEY: After speaking, restart listening for continuous conversation
    if (state.voiceMode) {
      setVoiceStatus('LISTENING...');
      setTimeout(startListening, 400);
    } else {
      setVoiceStatus('');
    }
  };

  utterance.onerror = function(event) {
    console.warn('TTS error:', event.error);
    state.isSpeaking = false;
    if (state.voiceMode) {
      setTimeout(startListening, 500);
    }
    setVoiceStatus('');
  };

  window.speechSynthesis.speak(utterance);
}

function setVoiceStatus(text) {
  const el = document.getElementById('voice-status');
  if (el) el.textContent = text;
}

// ---- BOOT ----
window.addEventListener('DOMContentLoaded', init);

// Pre-load voices (some browsers need this)
if (window.speechSynthesis) {
  window.speechSynthesis.onvoiceschanged = function() {
    window.speechSynthesis.getVoices();
  };
}
</script>
</body>
</html>